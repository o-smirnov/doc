file: ../MeqTrees/PSS4.27jan2004

         General: 

  -) We have decided to move the weekly PSS4 progress meeting from
  monday to tuesday (10:30).

  -) I understand from Kjeld that GVD is only available for 10% from
  now on. THis creates a new situation, which needs to be discussed.

  -) The WSRT group is getting more actively interested (LFFE looms).
  I have sketched the overall block-diagram of our future interaction
  for Tom Oosterloo (and Marco), with an indication of who is supposed
  to do what. Basically, we only promise a parameter-solving kernel,
  and the rest is up to them. It is still on my whiteboard, and we can
  discuss it before I turn it into a paper.

  -) This week, I will attend various meetings about LFFE and other
  WSRT plans, where we are supposed to play a role. This is a Good
  Thing, exercise-wise.

  -) Obviously, there is a lot of work to be done.
     - PSS3 emulation.
       - Larger trees.
     - Chained solvers (ripple-peeling).
     - Predicting extended sources.
     - Deriving secondary MeqParms (beamshape, ion.screen)
     - Predicting and subtracting Cat II sources.
     - WSRT M.E.
     - Processing strategies (scripts)
     - Closing the loop:
       - GSM/LSM organisation (VO interaction)
       - Residual imaging (facets)
       - Updating the GSM from residual images (trees also) 
     - Writing our article...


         Solving status
	 ==============

  -) Solving how seems to work for the 3 important cases:

     -) Solve for polc with only a single value (c00)

     -) Solve for multiple polc coeff (as long as the number of
     unknowns is smaller than the nr of equations, i.e. the nr of
     domain cells times the nr of MeqCondeqs) 

     -) Undedetermined system (singular matrix)


  -) JEN has 'perfected' two plots (see examples) that tell most of
  the story of a solution, in a POLICY-FREE way:

     -) The incremental values for the unknown MeqParm polc coeff,
     plotted against iteration nr. They should rapidly get smaller.

     -) The total chi-squared, calculated by adding the sum of the
     squares of vellsets of all the MeqCondeqs. THis should be zero at
     the minimum.

     -) The derivatives of chi-squared w.r.t. the solvable MeqParm
     polc coeff. These should be zero at the chisq minimum.

  -) Mirror-trees are a good (policy-free) way of testing trees. 

  -) GVD has made the following info available in the result record:

     -) A spid_index vector that tells us which increment belongs to
     which MeqParm polc coeff.

     -) The solver info provided bt WNB. However, there is no
     indication about how the solver has dealt with the situation
     without an explicit constraint.

  -) OMS has made the C++ trees persistent, in the sense that they may
  be saved in (and loaded from) a file. This works. 


         Some system issues
	 ==================

  -) DMI offers publish/subscibe, and the only thing that OMS needs to
  do to enable routine use from Glish is implementing (and testing!) 
  the Glish interface (~one day). I am inclined to think that this is
  worth the investment, since it offers all kinds of possibilities
  that I would like to play with (and exercise!). Some examples:

     -) After solving, the caches are empty. I need subscribe to
     follow what happens this way.

     -) I need subscribe to follos the request-sequence generated by
     the MeqSinks.

  -) As a related issue, I am planning to start using the pause/resume
  feature of DMI, and gradually move towards 'debugger functionality'
  like breakpoints and step-wise operation.

  -) We have to have a Python interface in place around september.
  This will allow the WSRT guys to write their own tree generation and
  process control scripts. 



         MeqParm requirements
	 ====================

Now that we have experimented a little with solving, it is time to
discuss the precise requirements on MeqParm behaviour again.

  -) JEN has experimented with modifying MeqParm values in the table.
  More specifically, after solving, he has reset the MeqParm values to
  their default values in the /DEFAULTVALUES subtable, and tried to
  solve again.
    
     -) Initially, it was not possible to access the mep table after
     solve, because it was still locked by the solver. This problem
     was solved by OMS.

     -) However, it still does not work since the MeqParms do not
     access the mep table before continuing with solving. Not even
     when the domain was changed....! 
       -) We need a flush command, which updates the mep table(s). 
       -) I would also like to be able to tell the solver that it
       should flush after each iteration.

  -) The majority of the mep table columns is now obsolete. Shouln't
  we remove them, for clarity and to save space?

  -) The /DEFAULTVALUES subtable has become a table that contains
  overall information about a MeqParm (the meptable itself contains
  zero or more rows for a MeqParm, with a polc per row). It seems more
  logical to organise this the other way around: the main table has
  one row per MeqParm, while a /POLCS subtable contains the polc rows.
  The main table would contain overall information like default
  values, and perhaps an overview of available polcs.... We really
  should clean this up (and exercise it!) before we start working in
  earnest. (NB: If there is a problem with backward compatibility with
  PSS3, this should not deter us!).
 


         MeqSolver features
	 ==================

Repeating a recent email to GVD:

  -) Will there be more information in the metrics if thee are
     problems, e.g. when SVD has had to add arbitrary constraint
     information to make the matrix invert

  -) What commands are available (or planned) for controlling a
     solver? E.g.
     -) reset (to zeroes)
     -) solve without reset (this allows us to continue accumulating 
        the same matrix with new equations)

  -) NB: In the future we need the possibility of accumulating 
     selected equations into a 'scratch' matrix, which can be 
     subtracted from the main solution matrix at some point. This
     is needed for 'gliding-window' solutions for dynamic domains.  

  -) When should we introduce double-derivatives? What form will that
     take in the cache_result? 




         Standard tests and demos
	 ========================

  -) I have made a start with a set of standard tests. 
     
     1) MeqSolver -> MeqCondeq -> 2 Meqparms (a,b)
        Simplest possible solving experiment
 
     2) MeqSolver -> MeqCondeq -> 2 Meqparms (a,a%)
        Simplest possible 'mirror' tree

     3) MeqSolver -> 3 MeqCondeqs -> MeqConstant (0)
          -> 3 MeqSubtract -> 3 MeqParms (phase[s=1,2,3]) 
        Underdetrmined system (phase-closure without constraint

     4) Same as 3), but with constraint (MeqAdd)
  
NB: The MeqParms in these trees have fixed default values, which I
will not change again. I still have to figure out a way to group all
the conditions (e.g. request/domain, etc)



                               =================================
