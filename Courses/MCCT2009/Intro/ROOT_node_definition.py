"""
file:  ../beginners_guide/TDL_script_node_definition.py
... description of this module
... copyright statement
"""

from Timba.TDL import *
import unique_nodestub as UN
import make_bookmark as BM
import execute_request as ER


#-------------------------------------------------------------  
# Required compile-time function: it defines the forest of trees of nodes.
# The global variable 'rootnode' represents the node that will receive the
# execution Request in the runtime function(s) '_tdl_job_xyz()' below.
#-------------------------------------------------------------  

TDLCompileMenu("TDL_script_node_definition:",
               TDLOption('copt_basic', 'basic', False,
                         doc='Basic node definition'),
               TDLOption('copt_leaves', 'leaves', False,
                         doc='Examples of leaf node definition'),
               TDLOption('copt_children', 'children', False,
                         doc='Assigning child nodes'),
               TDLOption('copt_autonodes', 'autonodes', False,
                         doc='Examples of automatic node generation'),
               TDLOption('copt_subscopes', 'subscopes', False,
                         doc='Subscopes create separate nodename-spaces'),
               TDLOption('copt_unique', 'unique', False,
                         doc='The use of unique node-stubs'),
               toggle='copt_node_definition')

#-------------------------------------------------------------  

def _define_forest (ns, **kwargs):
  """
  The code of this function may be inspected in the code section
  of the MeqBrowser. Its node result(s) may be inspected via the
  bookmark(s).

  Python MeqNodes are defined with the help of a two TDL objects:
  the nodescope object (ns) and the Meq object. The Python node
  specifications are later converted into C++ nodes by the meqserver.
  Here, we will concern ourselves only with the Python side.

  First of all, a 'nodestub' object is generated by qualifying the
  nodescope object with a name:  v = ns.a   or:  v = ns['a'].
  The [] form allows names with strange characters, and also names
  that are variables. Note that we assign the nodestub to a Python
  variable (v), which is not required, but highly recommended.

  For those who know a little Python, qualification of a nodescope
  object makes use of its __getattr__ method. The resulting nodestub
  can be qualified in its turn by using its __call__ method, which
  is the same as a function call: v1 = v(qual)  or: v1 = ns.a(qual).
  The qualifier may be a string, integer, float, complex etc. So,
  if qual=54, the result will be a nodestub named 'a:54'.

  Since the result is another nodestub, this process may be repeated
  ad infinitem: v2 = v(q1)(q2)(kw=4)

  A nodestub is converted into a MeqNode (object) by 'initialising'
  it with a node class, or type. This is done with the << operator,
  and the Meq object. The latter has a method for each available node
  class, with arguments to match. The latter will often be its children, 
  but some node classes require other arguments.

  Thus, the general syntax for MeqNode definition is:
  -  var = ns[name](qual)(..) << Meq[nodeclass]([args])

  NB: An initialized MeqNode is still a nodestub object. For the purpose
  of node definition, the main differences between them are the outcome
  of the test node.initialized(), which will return True or False.
  Very importantly, new nodestubs may be generated by qualifying any
  nodestub, whether it is initialized or not:
  - stub = ns.stub
  - node = stub << Meq.Constant(1.0)
  - stub1 = stub(1)
  - node2 = stub(2) << Meq.Freq()
  - stub23 = node2(3)

  Careful study of this collection of examples will give you the
  general idea. The examples are grouped. The groups may be selected
  with the TDLOptions, and each have their own bookmark. You should
  compare the Python code in the middle (Tabbed Tools) section of the
  MeqBrowser with the node results in the right (Gridded Viewers)
  section. The same groups are used in the Beginners Manual.

  Finally, a slightly more advanced, but very important, subject:
  A MeqNode is identified by its name, which must be unique. Trying
  to define a node with the same name as one that exists already
  (in the same nodescope!) produces an error. Obviously, this can
  cause problems in trees that re-use subtrees defined in imported
  modules. Some solutions are briefly discussed here. 
  
  """
  bb = []    # initialize the list of (root nodes of) node bundles


  if copt_basic:
    # First define a few nodestubs, and assign them to Python variables:
    ns.a1                          # --> a1(None)            #  
    a2 = ns.a2                     # --> a2(None)            #   
    a3 = ns['a3']                  # --> a3(None)            #    
    a4 = ns['a2+a3']               # --> a2+a3(None)         #    
    a5 = ns.a5('qual')             # --> a4:qual(None)       # qualifier  
    a6 = ns.a6(kwqual=5)           # --> a5:kwqual=5(None)   # keyword qualifier  
    a7 = ns.a7(3)('3')(x=-5.5)     # --> a7:3:3:x=-5.5(None) # multiple qualifiers  
    a8 = ns.a8(3,-4,5)             # --> a8:3:-4:5(None)     # multiple qualifiers  

    help = """
    Nodestubs are converted into MeqNodes (objects) by 'initialising'
    them with a node class, or type. This is done with the << operator,
    and the relevant method of the TDL Meq object: stub << Meq[class]([args])   
    """
    ns.a1 << 1.0                   # --> a1(MeqConstant)            # no variable 
    print '- before initialization: ',str(a2),type(a2)
    a2 << 2                        # --> a2(MeqConstant)            #   
    print '-  after initialization: ',str(a2),type(a2)
    a3 << Meq.Constant(-3)         # --> a3(MeqConstant)            #    
    a4 << Meq.Add(a2,a3)           # --> a2+a3(MeqAdd)              # 2 children   
    a5 << complex(4,5)             # --> a4:qual(MeqConstant)       #   
    a6 << Meq.Parm(5.0)            # --> a5:kwqual=5(MeqParm)       # default value   
    a7 << 5.0                      # --> a7:3:3:x=-5.5(MeqConstant) #   
    a8 << Meq.Constant([8,9])      # --> a8:3:-4:5(MeqConstant)     # tensor node  
    bb.append(node_bundle(ns, 'basic', help=help,
                          nodes=[ns.a1,a2,a3,a4,a5,a6,a7,a8]))


  if copt_leaves:
    help = """
    Leaf nodes have no children. Here are some of the often-used ones.
    The Meq[class]() argument is usually unambiguous, but it is sometimes
    better to specify it by name (e.g. Meq.GaussNoise(stddev=..)).
    """
    b1 = ns.scalar << Meq.Constant(1.0)          # --> b1(MeqConstant)         # value=1.0 
    b2 = ns.tensor << Meq.Constant([3,4,-1])     # --> b2(MeqConstant)         # tensor node   
    b3 = ns.parm << Meq.Parm(-1.0)               # --> b3(MeqParm)             # default=-1.0   
    b4 = ns.freq << Meq.Freq()                   # --> b4(MeqFreq)             #    
    b5 = ns.time << Meq.Time                     # --> b5(MeqTime)             # same as Meq.Time()   
    b6 = ns.gauss << Meq.GaussNoise(stddev=1.5)  # --> b6(MeqGaussNoise)       #   
    bb.append(node_bundle(ns, 'leaves', help=help,
                          nodes=[b1,b2,b3,b4,b5,b6]))

    
  if copt_children:
    help = """
    Most node classes require one or more child nodes. Usually, these are given
    as the first argument(s) of the relevant method of the TDL Meq object.
    Multiple children can also be supplied as a list: Meq[class](*cc).
    However, if there are other arguments as well, the children must be
    specified with the 'children' keyword:  Meq[class](children=cc, arg=..).
    Note that the order of the child nodes is usually important.
    """
    c1 = ns.c1 << Meq.Freq()                 # --> c1(MeqFreq)            # child 1 
    c2 = ns.c2 << Meq.Time()                 # --> c2(MeqTime)            # child 2
    c3 = ns.c3 << Meq.Add(c1,c2)             # --> c3(MeqAdd)             
    c4 = ns.c4 << Meq.Add(*[c1,c2])          # --> c4(MeqAdd)
    c5 = ns.c5 << Meq.Add(children=[c1,c2], option='opt')    # --> c5(MeqAdd)
    c6 = ns.c6 << getattr(Meq,'Cos')(c5)     # --> c6(MeqCos)             # node-class as variable 
    bb.append(node_bundle(ns, 'children', help=help,
                          nodes=[c1,c2,c3,c4,c5,c6]))

    
  if copt_autonodes:
    help = """
    If no nodename is specified, the nodescope will do its best to generate automatic
    nodenames. If an initialized node of this name already exists, it will modify the
    name until it is unique. If is even clever enough to use the same name if this
    cannot lead to ambiguity (i.e. if the children are the same too).
    It is also possible to define subtrees by giving expressions of nodes and numbers.
    MeqTrees will recognize the Python math operations +,-,*,/  and the Python math
    functions abs() and ...?.
    """
    d1 = ns << 67                  # --> (constant)(MeqConstant)    # automatic node  
    d2 = ns << Meq.Freq()          # --> (freq)(MeqFreq)            #    
    d3 = ns << Meq.Freq()          # --> (freq)1(MeqFreq)           # unique name   
    d4 = ns << Meq.Cos(d2)         # --> cos((freq))(MeqCos)        #   
    d5 = ns << Meq.Cos(d2)         # --> cos((freq))(MeqCos)        # same node!  
    d6 = ns << d3+d1               # --> add((freq)1,(constant))    # automatic MeqAdd  
    d7 = ns.mathexpr << (d3-d1)/d5 # --> mathexpr(MeqDivide)        # Python math expression  
    d8 = ns.mathfunc << abs(d4)    # --> mathfunc(MeqAbs)           # Python math function  
    bb.append(node_bundle(ns, 'autonodes', help=help,
                          nodes=[d1,d2,d3,d4,d5,d6,d7,d8]))


  if copt_subscopes:
    help = """
    One way to avoid nodename clashes is to use subscopes, which define a
    (hopefully) unique namespace by prepending all nodenames with the name
    of the subscope. A subscope may be derived from a nodescope (ns) or
    another subscope (ss). It is then used just like a regular nodescope in
    the definition of MeqNodes. Obviously, it can also be passed to other
    tree-definition functions instead of the regular nodescope.
    """
    ss1 = ns.Subscope('sub1')             # derive a subscope object from the nodescope   
    print 'type(ss) =',type(ss1)          # --> <class 'Timba.TDL.TDLimpl.NodeScope'>
    e1 = ss1.e1 << 1.0                    # --> sub1::e1(MeqConstant)
    ss2 = ss1.Subscope('sub2')            # subscopes may be derived from another subscope   
    e2 = ss2.e2 << 2.0                    # --> sub1::sub2::e2(MeqConstant)
    ss3 = ns.Subscope('sub3')('aa')(6)    # subscopes may also be qualified    
    e3 = ss3.e3 << 3.0                    # --> sub3::e3:aa:6(MeqConstant)
    bb.append(node_bundle(ns, 'subscope', help=help,
                          nodes=[e1,e2,e3]))


  if copt_unique:
    help = """
    Another strategy for reducing the chance of nodename clashes is to use
    tree-definition functions that accept a nodestub (initialized or not)
    rather than a nodescope, and then generate new nodes by qualifying the
    given nodestub. The chance of nodename clashes is greatly reduced if
    the given nodestub has an unique name. This is the purpose of the helper
    function .unique_nodestub(ns, name) in module unique_nodestub.py:
    """
    stub = UN.unique_nodestub(ns,'g')     # --> g(MeqConstant)      # initialized stub
    g1 = stub(1) << 1.0                   # --> g:1(MeqConstant)
    g2 = stub(-2.0) << -2.0               # --> g:-2.0(MeqConstant)
    stub = UN.unique_nodestub(ns,'g')     # --> g|(MeqConstant)     # initialized stub
    stub = UN.unique_nodestub(ns,'g')     # --> g||(MeqConstant)    # initialized stub
    g3 = stub(3) << 3.0                   # --> g||:3(MeqConstant) 
    bb.append(node_bundle(ns, 'unique_nodestubs',
                          help=help+'\n\n'+UN.unique_nodestub.__doc__, 
                          nodes=[g1,g2,g3]))


  # Bundle the node-bundles:
  global rootnode
  rootnode = node_bundle(ns, 'node_definition', bb, bookmark=False)
  rootnode = BM.bookpage_function_result(rootnode, _define_forest,
                                         show_state=False, ns=ns)
  return None



#-------------------------------------------------------------  
# Helper functions:
#-------------------------------------------------------------  

def node_bundle(ns, name, nodes, help=None, bookmark=True):
  """Helper function to bundle the given nodes by making them
  the children of a single MeqComposer node.
  Bundling is necessary to supply the nodes with a request. 
  Optionally, generate a bookmark for a page of their results.
  If help is specified (string), include it in the bookpage.
  """
  node = ns.node_bundle(name) << Meq.Composer(*nodes)
  if bookmark:
    BM.bookpage_nodes (nodes, name=name, help=help)
  return node



#-------------------------------------------------------------  
# Runtime functions have names that begin with '_tdl_job_'.
# They will appear in the runtime menu (under the 'TDL exec' button).
#-------------------------------------------------------------  
  
def _tdl_job_execute_request (mqs, parent):
  """
  Execute by issuing a request to the node in the global variable 'rootnode'.
  The size and cells of the Request domain may be specified in the runtime menu.
  """
  return ER.execute_request(mqs, rootnode.name)


#-------------------------------------------------------------  
#  For testing without the meqbrowser, type '> python TDL_script_node_definition.py'
#-------------------------------------------------------------  

if __name__ == '__main__':
  print '\n** Start of standalone test of: TDL_script_node_definition.py:\n' 
  ns = NodeScope()

  if 0:
    _define_forest(ns)

  ns.resolve()
  print '\n** End of standalone test of: TDL_script_node_definition.py:\n' 

#-------------------------------------------------------------  

